import{writable as t,derived as e,get as s}from"svelte/store";const r=(t,e)=>{if(!Array.isArray(t))return null;for(const s of t)if("function"==typeof s)try{const t=s(e);if(null!=t)return t}catch(t){console.error("validator error",s,t)}return null};class l{constructor(s,l=[]){this.initial=s,this.validators=l,this.value=t(this.initial),this.touched=t(!1),this.state=e([this.value,this.touched],([t,e])=>{const s=r(this.validators,t);return{$error:s,$valid:null==s,$touched:e,$dirty:this.initial!==t}})}setTouched(t){this.touched.set(t)}getControl(){return null}reset(t){this.touched.set(!1),null!=t&&(this.initial=t),this.value.set(this.initial)}setValidators(t){Array.isArray(t)&&t.length&&(this.validators=t)}}const o=/^([^.[]+)\.?(.*)$/;class i{constructor(t,l=[]){this.controls=t,this.validators=l,this.valueDerived=e(this.initControls(this.controls),t=>t),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(s(this.valueDerived)))},this.state=e(this.value,t=>{const e={};let l=!0,o=!1,i=!1;for(const t of Object.keys(this.controls)){const r=e[t]=s(this.controls[t].state);l=l&&r.$valid,o=o||r.$touched,i=i||r.$dirty}const n=r(this.validators,t),a=null==n&&l;return Object.assign({$error:n,$valid:a,$touched:o,$dirty:i},e)})}initControls(t){const s=Object.keys(t),r=s.map(t=>this.controls[t]).map(t=>t.value);return e(r,t=>t.reduce((t,e,r)=>(t[s[r]]=e,t),{}))}setValue(t){Object.keys(this.controls).forEach(e=>{this.controls[e].value.set(t[e])})}getControl(t){const[e,s,r]=t.match(o)||[],l=s&&this.controls[s]||null;return l?r?l.getControl(r):l:null}reset(t){Object.keys(this.controls).forEach(e=>{this.controls[e].reset(t[e])})}setValidators(t){Array.isArray(t)&&t.length&&(this.validators=t)}}const n=/^\[(\d+)\]\.?(.*)$/;class a{constructor(l,o=[]){this.controls=l,this.validators=o,this.controlStore=t(this.controls),this.valueDerived=e(this.controlStore,(t,s)=>e(t.map(t=>t.value),t=>t).subscribe(s)),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(s(this.valueDerived)))},this.state=e([this.value,this.controlStore],([t,e])=>{const l=[];let o=!0;for(let t=0,r=e.length;t<r;t++){const r=s(e[t].state);l[t]=r,o=o&&r.$valid,l.$touched=l.$touched||r.$touched,l.$dirty=l.$dirty||r.$dirty}return l.$error=r(this.validators,t),l.$valid=null==l.$error&&o,l})}setValue(t){s(this.controlStore).forEach((e,s)=>e.value.set(t[s]))}get size(){return s(this.controlStore).length}pushControl(t){this.controlStore.update(e=>(e.push(t),e))}addControlAt(t,e){this.controlStore.update(s=>(s.splice(t,0,e),s))}removeControlAt(t){this.controlStore.update(e=>(e.splice(t,1),e))}slice(t=0,e){this.controlStore.update(s=>s.slice(t,e))}getControl(t){const[e,s,r]=t.match(n)||[],l=null!=s&&this.controls[+s]||null;return l?r?l.getControl(r):l:null}reset(t){s(this.controlStore).forEach((e,s)=>e.reset(t&&t[s]))}setValidators(t){Array.isArray(t)&&t.length&&(this.validators=t)}}const u=(t,e)=>{if(!(e instanceof l))throw new Error("must be used with a Control class");const s=t.classList,r=e.state.subscribe(t=>{t.$error?(s.add("invalid"),s.remove("valid")):(s.add("valid"),s.remove("invalid")),t.$dirty?(s.add("dirty"),s.remove("pristine")):(s.add("pristine"),s.remove("dirty")),t.$touched?s.add("touched"):s.remove("touched")}),o=["blur","focusout"],i=()=>o.forEach(e=>t.removeEventListener(e,n)),n=()=>{e.setTouched(!0),i()};return o.forEach(e=>t.addEventListener(e,n)),{destroy(){i(),r()}}},c=({onlyTouched:t=!1}={})=>(e,s)=>{if(!(s instanceof l))throw new Error("must be used with a Control class");return{destroy:s.state.subscribe(s=>{const r=s,l=!(t&&!r.$touched||!r.$error);e.hidden=!l,l&&(e.innerHTML=r.$error)})}},h=c(),d=(t,e=!0)=>s=>{let r=null!=s?`${s}`:"";return e&&(r=r.trim()),""!==r?null:t},v=/^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,$=t=>e=>null==e||v.test(e)?null:t,y=(t,e)=>s=>null!=s&&(null==e||`${s}`.length>=e)?null:t,b=(t,e)=>s=>null!=s&&(null==e||`${s}`.length<=e)?null:t,f=t=>e=>null==e||!isNaN(e)?null:t,p=/^[\d.]+$/,m=t=>e=>null==e||!isNaN(e)&&p.test(`${e}`)?null:t,g=/^[\d]+$/,A=t=>e=>null==e||!isNaN(e)&&g.test(`${e}`)?null:t,C=(t,e)=>s=>null==s||!isNaN(s)&&(null==e||s>=e)?null:t,E=(t,e)=>s=>null==s||!isNaN(s)&&(null==e||s<=e)?null:t,N=(t,e)=>s=>null==s||null==e||e.test(s)?null:t;export{l as Control,a as ControlArray,i as ControlGroup,u as controlClasses,h as controlError,c as controlErrorFactory,m as decimal,$ as email,A as integer,E as max,b as maxLength,C as min,y as minLength,f as number,N as pattern,d as required};
//# sourceMappingURL=index.mjs.map
