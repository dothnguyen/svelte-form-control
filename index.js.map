{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/control.ts","../src/use-actions.ts","../src/validators.ts"],"sourcesContent":["import { ValidatorFn } from \"./validators\";\n\nexport const chainValidators: (validators: ValidatorFn[]) => ValidatorFn = validators => {\n\tif (!Array.isArray(validators)) return (value: any) => null;\n\treturn fieldValue => {\n\t\tfor (const validator of validators) {\n\t\t\tconst result = validator(fieldValue);\n\t\t\tif (result) return result;\n    }\n    return null;\n\t}\n}\n\nexport const validateIterated = <T>(validators: ValidatorFn<T>[], fieldValue: T) => {\n\tif (!Array.isArray(validators)) return null;\n\t\tfor (const validator of validators) {\n\t\t\tif (typeof validator === 'function') {\n        try {\n\t\t\t\t\tconst result = validator(fieldValue);\n\t\t\t\t\tif (result != null) return result;\n        } catch (e) {\n          console.error(`validator error`, validator, e);\n        }\n      }\n    }\n    return null;\n}\n","import { derived, get, Readable, writable, Writable } from 'svelte/store';\nimport { validateIterated } from './utils';\nimport { ValidatorFn } from './validators';\n\ntype GroupValue<T> = { [K in keyof T]: T[K] };\n\ntype ControlTypes = string | number | boolean;\n\nexport interface $ControlState {\n  $error: string | null;\n\n  $valid: boolean;\n\n  $touched: boolean;\n\n  $dirty: boolean;\n}\n\ntype ControlState<T = any> = T extends (infer K)[] ? Array<ControlState<K> & $ControlState>\n  : T extends ControlTypes ? $ControlState\n  : T extends GroupValue<T> ? { [K in keyof T]: ControlState<T[K]> & $ControlState }\n  : $ControlState;\n\nexport interface ControlBase<T = any> {\n  value: Writable<T>;\n\n  state: Readable<ControlState<T>>;\n\n  getControl(path: string): ControlBase;\n\n  reset(value?: T): void;\n\n}\n\nexport class Control<T = ControlTypes> implements ControlBase<T> {\n\n  value = writable<T>(this.initial);\n\n  private touched = writable(false);\n\n  state = derived([this.value, this.touched], ([value, $touched]) => {\n    const $error = validateIterated(this.validators, value);\n    const $valid = $error == null;\n    const $dirty = this.initial !== value;\n    return { $error, $valid, $touched, $dirty } as ControlState<T>;\n  });\n\n  constructor(\n    private initial: T,\n    private readonly validators: ValidatorFn<T>[] = [],\n  ) { }\n\n  setTouched(touched: boolean) {\n    this.touched.set(touched);\n  }\n\n  getControl() {\n    return null!;\n  }\n\n  reset(value?: T) {\n    this.touched.set(false);\n    if (value != null) this.initial = value;\n    this.value.set(this.initial);\n  };\n\n}\n\ntype Controls<T> = { [K in keyof T]: ControlBase<T[K]> };\n\nconst objectPath = /^([^.[]+)\\.?(.*)$/;\n\nexport class ControlGroup<T> implements ControlBase<T> {\n\n  private valueDerived = derived(this.initControls(this.controls), value => value);\n\n  value: Writable<T> = {\n    subscribe: this.valueDerived.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueDerived))),\n  };\n\n  state = derived(this.value, value => {\n    const children: Record<string, $ControlState> = {};\n    let childError = false;\n    let $touched = false;\n    let $dirty = false;\n    for (const key of Object.keys(this.controls)) {\n      const state = children[key] = get(((this.controls as any)[key] as ControlBase).state) as $ControlState;\n      childError = childError || state.$error != null;\n      $touched = $touched || state.$touched;\n      $dirty = $dirty || state.$dirty;\n    }\n    const $error = validateIterated(this.validators, value);\n    const $valid = $error == null && !childError;\n    return { $error, $valid, $touched, $dirty, ...children } as ControlState<T>;\n  });\n\n  constructor(\n    private readonly controls: Controls<T>,\n    private readonly validators: ValidatorFn<T>[] = [],\n  ) { }\n\n  private initControls(controls: Controls<T>) {\n    const keys = Object.keys(controls);\n    const controlList = keys.map(key => (<any>this.controls)[key]);\n    const readables = controlList.map(control => control.value) as any as [Readable<any>, ...Readable<any>[]];\n    return derived(readables, (values: any[]) =>\n      values.reduce((acc, value, index) => (acc[keys[index]] = value, acc), {}) as T);\n  }\n\n  private setValue(value: T) {\n    Object.keys(this.controls).forEach(key => {\n      const control = (this.controls as any)[key] as ControlBase;\n      control.value.set((value as any)[key]);\n    });\n  }\n\n  // TODO: add control, remove control\n\n  getControl(path: string) {\n    const [_, name, rest] = path.match(objectPath) || [];\n    const control = name && (this.controls as any)[name] as ControlBase || null;\n    if (!control) return null!;\n    return rest ? control.getControl(rest) : control;\n  }\n\n  reset(value?: T) {\n    Object.keys(this.controls).forEach(key => {\n      const control = (this.controls as any)[key] as ControlBase;\n      control.reset((value as any)[key]);\n    });\n  };\n\n}\n\nconst arrayPath = /^\\[(\\d+)\\]\\.?(.*)$/;\n\nexport class ControlArray<T> implements ControlBase<T[]> {\n\n  private controlStore = writable(this.controls);\n\n  private valueDerived = derived(this.controlStore, (controls: ControlBase<T>[], set: (value: T[]) => void) => {\n    const derivedValues = derived(\n      controls.map(control => control.value) as any as [Readable<T>, ...Readable<T>[]],\n      values => values as T[]);\n    return derivedValues.subscribe(set);\n  });\n\n  value: Writable<T[]> = {\n    subscribe: this.valueDerived.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueDerived))),\n  };\n\n  state = derived([this.value, this.controlStore], ([value, controls]) => {\n    const children: $ControlState & $ControlState[] = [] as any;\n    let childError = false;\n    for (let i = 0, len = controls.length; i < len; i++) {\n      const state: $ControlState = get(controls[i].state);\n      children[i] = state;\n      childError = childError || state.$error != null;\n      children.$touched = children.$touched || state.$touched;\n      children.$dirty = children.$dirty || state.$dirty;\n    }\n    children.$error = validateIterated(this.validators, value);\n    children.$valid = children.$error == null && !childError;\n\n    return children as any as ControlState<T[]>;\n  });\n\n  constructor(\n    private readonly controls: ControlBase<T>[],\n    private readonly validators: ValidatorFn<T[]>[] = [],\n  ) {\n  }\n\n  private setValue(value: T[]) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach((control, index) => control.value.set(value[index]));\n  }\n\n  get size() {\n    return (get(this.controlStore) as ControlBase<T>[]).length;\n  }\n\n  pushControl(control: ControlBase<T>) {\n    this.controlStore.update(stores => (stores.push(control), stores));\n  }\n\n  addControlAt(index: number, control: ControlBase<T>) {\n    this.controlStore.update(stores => (stores.splice(index, 0, control), stores));\n  }\n\n  removeControlAt(index: number) {\n    this.controlStore.update(stores => (stores.splice(index, 1), stores));\n  }\n\n  slice(start = 0, end?: number) {\n    this.controlStore.update(stores => stores.slice(start, end));\n  }\n\n  getControl(path: string) {\n    const [_, index, rest] = path.match(arrayPath) || [];\n    const control = index != null && this.controls[+index] || null;\n    if (!control) return null!;\n    return rest ? control.getControl(rest) : control;\n  }\n\n  reset(value?: T[]) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach((control, index) => control.reset(value && value[index]));\n  }\n\n}\n","import { $ControlState, Control, ControlBase } from \"./control\";\n\nexport const controlClasses = (el: HTMLElement, control: Control) => {\n\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\tconst classList = el.classList;\n\n\tconst stateSub = control.state.subscribe((state) => {\n\t\tif (state.$error) {\n\t\t\tclassList.add('invalid');\n\t\t\tclassList.remove('valid');\n\t\t} else {\n\t\t\tclassList.add('valid');\n\t\t\tclassList.remove('invalid');\n\t\t}\n\n\t\tif (state.$dirty) {\n\t\t\tclassList.add('dirty');\n\t\t\tclassList.remove('pristine');\n\t\t} else {\n\t\t\tclassList.add('pristine');\n\t\t\tclassList.remove('dirty');\n\t\t}\n\n\t\tif (state.$touched) {\n\t\t\tclassList.add('touched');\n\t\t} else {\n\t\t\tclassList.remove('touched');\n\t\t}\n\n\t});\n\n\tconst eventNames = ['blur', 'focusout'];\n\n\tconst unregister = () => eventNames.forEach(eventName => el.removeEventListener(eventName, touchedFn));\n\n\tconst touchedFn = () => {\n\t\tcontrol.setTouched(true);\n\t\tunregister();\n\t}\n\n\teventNames.forEach(eventName => el.addEventListener(eventName, touchedFn));\n\n\treturn {\n\t\tdestroy() {\n\t\t\tunregister();\n\t\t\tstateSub();\n\t\t}\n\t}\n};\n\nexport const controlErrorFactory = ({ onlyTouched = false } = {}) =>\n\t(el: HTMLElement, control: ControlBase) => {\n\t\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\t\tconst stateSub = control.state.subscribe(_state => {\n\t\t\tconst state = (_state as $ControlState);\n\t\t\tconst hasError = !!((!onlyTouched || state.$touched) && state.$error);\n\t\t\tel.hidden = !hasError;\n\t\t\tif (hasError) el.innerHTML = state.$error!;\n\t\t});\n\n\t\treturn { destroy: stateSub };\n\t};\n\n\nexport const controlError = controlErrorFactory();\n","export type ValidatorFn<T = any> = (fieldValue: T) => string | null;\n\ntype ValidatorFactory<T = unknown> = (message: string, config?: T) => ValidatorFn;\n\nexport const required: ValidatorFactory = (message, trim = true) => value => {\n\tlet stringValue = value != null ? `${value}` : '';\n\tif (trim) stringValue = stringValue.trim();\n\treturn stringValue !== '' ? null : message;\n};\n\nconst emailFormat = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\nexport const email: ValidatorFactory = message => email => {\n\tconst valid = email == null || emailFormat.test(email);\n\treturn valid ? null : message;\n};\n\nexport const minLength: ValidatorFactory<number> = (message, min) => value => {\n\tconst valid = value != null && (min == null || `${value}`.length >= min);\n\treturn valid ? null : message;\n};\n\nexport const maxLength: ValidatorFactory<number> = (message, max) => value => {\n\tconst valid = value != null && (max == null || `${value}`.length <= max);\n\treturn valid ? null : message;\n};\n\nexport const number: ValidatorFactory = message => number => {\n\tconst valid = number == null || !isNaN(number);\n\treturn valid ? null : message;\n};\n\nconst decimalFormat = /^[\\d.]+$/;\nexport const decimal: ValidatorFactory = message => number => {\n\tconst valid = number == null || !isNaN(number) && decimalFormat.test(`${number}`);\n\treturn valid ? null : message;\n};\n\nconst intFormat = /^[\\d]+$/;\nexport const integer: ValidatorFactory = message => number => {\n\tconst valid = number == null || !isNaN(number) && intFormat.test(`${number}`);\n\treturn valid ? null : message;\n};\n\n\n\nexport const min: ValidatorFactory<number> = (message, min) => number => {\n\tconst valid = number == null || !isNaN(number) && (min == null || number >= min);\n\treturn valid ? null : message;\n};\n\nexport const max: ValidatorFactory<number> = (message, max) => number => {\n\tconst valid = number == null || !isNaN(number) && (max == null || number <= max);\n\treturn valid ? null : message;\n};\n\nexport const pattern: ValidatorFactory<RegExp> = (message, re) => text => {\n\tconst valid = text == null || (re == null || re.test(text));\n\treturn valid ? null : message;\n};\n\n"],"names":["validateIterated","validators","fieldValue","Array","isArray","validator","result","e","console","error","Control","[object Object]","initial","this","writable","derived","value","touched","$touched","$error","$valid","$dirty","set","objectPath","arrayPath","controlErrorFactory","onlyTouched","el","control","Error","destroy","state","subscribe","_state","hasError","hidden","innerHTML","controlError","emailFormat","decimalFormat","intFormat","controls","controlStore","map","values","valueDerived","setValue","update","updater","get","children","childError","i","len","length","forEach","index","size","stores","push","splice","start","end","slice","path","_","rest","match","getControl","reset","initControls","key","Object","keys","readables","reduce","acc","name","classList","stateSub","add","remove","eventNames","unregister","eventName","removeEventListener","touchedFn","setTouched","addEventListener","message","number","isNaN","test","email","max","min","re","text","trim","stringValue"],"mappings":"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"}