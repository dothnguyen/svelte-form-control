{"version":3,"file":"index.mjs","sources":["../src/utils.ts","../src/control.ts","../src/use-actions.ts","../src/validators.ts"],"sourcesContent":["import { ValidatorFn } from \"./validators\";\n\nexport const chainValidators: (validators: ValidatorFn[]) => ValidatorFn = validators => {\n\tif (!Array.isArray(validators)) return (value: any) => null;\n\treturn fieldValue => {\n\t\tfor (const validator of validators) {\n\t\t\tconst result = validator(fieldValue);\n\t\t\tif (result) return result;\n    }\n    return null;\n\t}\n}\n\nexport const validateIterated = <T>(validators: ValidatorFn<T>[], fieldValue: T) => {\n\tif (!Array.isArray(validators)) return null;\n\t\tfor (const validator of validators) {\n\t\t\tif (typeof validator === 'function') {\n        try {\n\t\t\t\t\tconst result = validator(fieldValue);\n\t\t\t\t\tif (result != null) return result;\n        } catch (e) {\n          console.error(`validator error`, validator, e);\n        }\n      }\n    }\n    return null;\n}\n","import { derived, get, Readable, writable, Writable } from 'svelte/store';\nimport { validateIterated } from './utils';\nimport { ValidatorFn } from './validators';\n\ntype GroupValue<T> = { [K in keyof T]: T[K] };\n\ntype ControlTypes = string | number | boolean;\n\nexport interface $ControlState {\n  $error: string | null;\n\n  $valid: boolean;\n\n  $touched: boolean;\n\n  $dirty: boolean;\n}\n\ntype ControlState<T = any> = T extends (infer K)[] ? Array<ControlState<K> & $ControlState>\n  : T extends ControlTypes ? $ControlState\n  : T extends GroupValue<T> ? { [K in keyof T]: ControlState<T[K]> & $ControlState }\n  : $ControlState;\n\nexport abstract class ControlBase<T = any> {\n\n  constructor(protected validators: ValidatorFn<T>[]) { }\n\n  abstract value: Writable<T>;\n\n  abstract state: Readable<ControlState<T>>;\n\n  abstract getControl(path: string): ControlBase;\n\n  abstract reset(value?: T): void;\n\n  abstract setTouched(touched: boolean): void;\n\n  setValidators(validators: ValidatorFn<T>[]) {\n    if (!(Array.isArray(validators) && validators.length)) return;\n    this.validators = validators;\n  }\n\n}\n\nexport class Control<T = ControlTypes> extends ControlBase<T> {\n\n  value = writable<T>(this.initial);\n\n  private touched = writable(false);\n\n  state = derived([this.value, this.touched], ([value, $touched]) => {\n    const $error = validateIterated(this.validators, value);\n    const $valid = $error == null;\n    const $dirty = this.initial !== value;\n    return { $error, $valid, $touched, $dirty } as ControlState<T>;\n  });\n\n  constructor(\n    private initial: T,\n    validators: ValidatorFn<T>[] = [],\n  ) {\n    super(validators);\n  }\n\n  setTouched(touched: boolean) {\n    this.touched.set(touched);\n  }\n\n  getControl() {\n    return null!;\n  }\n\n  reset(value?: T) {\n    this.touched.set(false);\n    if (value != null) this.initial = value;\n    this.value.set(this.initial);\n  };\n\n}\n\ntype Controls<T> = { [K in keyof T]: ControlBase<T[K]> };\n\nconst objectPath = /^([^.[]+)\\.?(.*)$/;\n\nconst controlsValueReadable = <T>(controls: Controls<T>) => {\n  const keys = Object.keys(controls);\n  const controlList = keys.map(key => (<any>controls)[key]);\n  const readables = controlList.map(control => control.value) as any as [Readable<any>, ...Readable<any>[]];\n  return derived(readables, (values: any[]) =>\n    values.reduce((acc, value, index) => (acc[keys[index]] = value, acc), {}) as T);\n};\n\nconst controlsStateReadable = <T>(controls: Controls<T>) => {\n  const keys = Object.keys(controls);\n  const controlList = keys.map(key => (<any>controls)[key]);\n  const readables = controlList.map(control => control.state) as any as [Readable<any>, ...Readable<any>[]];\n  return derived(readables, (states: any[]) =>\n    states.reduce((acc, state, index) => (acc[keys[index]] = state, acc), {}) as { [K in keyof T]: $ControlState });\n};\n\nexport class ControlGroup<T> extends ControlBase<T> {\n\n  private valueReadable = controlsValueReadable(this.controls);\n\n  private childStateReadable = controlsStateReadable(this.controls);\n\n  value: Writable<T> = {\n    subscribe: this.valueReadable.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueReadable))),\n  };\n\n  state = derived([this.valueReadable, this.childStateReadable], ([value, childState]) => {\n    const children: Record<string, $ControlState> = {};\n    let childrenValid = true;\n    let $touched = false;\n    let $dirty = false;\n    for (const key of Object.keys(this.controls)) {\n      const state = children[key] = (childState as any)[key] as $ControlState;\n      childrenValid = childrenValid && state.$valid;\n      $touched = $touched || state.$touched;\n      $dirty = $dirty || state.$dirty;\n    }\n    const $error = validateIterated(this.validators, value);\n    const $valid = $error == null && childrenValid;\n    return { $error, $valid, $touched, $dirty, ...children } as ControlState<T>;\n  });\n\n  constructor(\n    private readonly controls: Controls<T>,\n    validators: ValidatorFn<T>[] = [],\n  ) {\n    super(validators);\n  }\n\n  private setValue(value: T) {\n    Object.keys(this.controls).forEach(key => {\n      const control = (this.controls as any)[key] as ControlBase;\n      control.value.set((value as any)[key]);\n    });\n  }\n\n  setTouched(touched: boolean) {\n    Object.keys(this.controls).forEach(key => {\n      const control = (this.controls as any)[key] as ControlBase;\n      control.setTouched(touched);\n    });\n  }\n\n  getControl(path: string) {\n    const [_, name, rest] = path.match(objectPath) || [];\n    const control = name && (this.controls as any)[name] as ControlBase || null;\n    if (!control) return null!;\n    return rest ? control.getControl(rest) : control;\n  }\n\n  reset(value?: T) {\n    Object.keys(this.controls).forEach(key => {\n      const control = (this.controls as any)[key] as ControlBase;\n      control.reset((value as any)[key]);\n    });\n  };\n\n}\n\nconst arrayPath = /^\\[(\\d+)\\]\\.?(.*)$/;\n\nexport class ControlArray<T> extends ControlBase<T[]> {\n\n  private controlStore = writable(this._controls);\n\n  private valueDerived = derived(this.controlStore, (controls: ControlBase<T>[], set: (value: T[]) => void) => {\n    const derivedValues = derived(\n      controls.map(control => control.value) as any as [Readable<T>, ...Readable<T>[]],\n      values => values as T[]);\n    return derivedValues.subscribe(set);\n  });\n\n  private childStateDerived = derived(this.controlStore,\n    (controls: ControlBase<T>[], set: (value: $ControlState[]) => void) => {\n      const derivedValues = derived(\n        controls.map(control => control.state) as any as [Readable<$ControlState>, ...Readable<$ControlState>[]],\n        values => values as $ControlState[]);\n      return derivedValues.subscribe(set);\n    });\n\n  value: Writable<T[]> = {\n    subscribe: this.valueDerived.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueDerived))),\n  };\n\n  state = derived([this.valueDerived, this.childStateDerived], ([value, childState]) => {\n    const children: $ControlState & $ControlState[] = [] as any;\n    let childrenValid = true;\n    for (let i = 0, len = childState.length; i < len; i++) {\n      const state = childState[i];\n      children[i] = state;\n      childrenValid = childrenValid && state.$valid;\n      children.$touched = children.$touched || state.$touched;\n      children.$dirty = children.$dirty || state.$dirty;\n    }\n    children.$error = validateIterated(this.validators, value);\n    children.$valid = children.$error == null && childrenValid;\n\n    return children as any as ControlState<T[]>;\n  });\n\n  constructor(\n    private readonly _controls: ControlBase<T>[],\n    validators: ValidatorFn<T[]>[] = [],\n  ) {\n    super(validators);\n  }\n\n  private setValue(value: T[]) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach((control, index) => control.value.set(value[index]));\n  }\n\n  setTouched(touched: boolean) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach(control => control.setTouched(touched));\n  }\n\n  get size() {\n    return (get(this.controlStore) as ControlBase<T>[]).length;\n  }\n\n  get controls() {\n    return (get(this.controlStore) as ControlBase<T>[]);\n  }\n\n  pushControl(control: ControlBase<T>) {\n    this.controlStore.update(stores => (stores.push(control), stores));\n  }\n\n  addControlAt(index: number, control: ControlBase<T>) {\n    this.controlStore.update(stores => (stores.splice(index, 0, control), stores));\n  }\n\n  removeControlAt(index: number) {\n    this.controlStore.update(stores => (stores.splice(index, 1), stores));\n  }\n\n  slice(start?: number, end?: number) {\n    this.controlStore.update(stores => stores.slice(start, end));\n  }\n\n  getControl(path: string) {\n    const [_, index, rest] = path.match(arrayPath) || [];\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    const control = index != null && controls[+index] || null;\n    if (!control) return null!;\n    return rest ? control.getControl(rest) : control;\n  }\n\n  reset(value?: T[]) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach((control, index) => control.reset(value && value[index]));\n  }\n\n  setValidators(validators: ValidatorFn<T[]>[]) {\n    if (!(Array.isArray(validators) && validators.length)) return;\n    this.validators = validators;\n  }\n\n}\n","import { $ControlState, Control, ControlBase } from \"./control\";\n\nexport const controlClasses = (el: HTMLElement, control: Control) => {\n\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\tconst classList = el.classList;\n\n\tconst stateSub = control.state.subscribe((state) => {\n\t\tif (state.$error) {\n\t\t\tclassList.add('invalid');\n\t\t\tclassList.remove('valid');\n\t\t} else {\n\t\t\tclassList.add('valid');\n\t\t\tclassList.remove('invalid');\n\t\t}\n\n\t\tif (state.$dirty) {\n\t\t\tclassList.add('dirty');\n\t\t\tclassList.remove('pristine');\n\t\t} else {\n\t\t\tclassList.add('pristine');\n\t\t\tclassList.remove('dirty');\n\t\t}\n\n\t\tif (state.$touched) {\n\t\t\tclassList.add('touched');\n\t\t} else {\n\t\t\tclassList.remove('touched');\n\t\t}\n\n\t});\n\n\tconst eventNames = ['blur', 'focusout'];\n\n\tconst unregister = () => eventNames.forEach(eventName => el.removeEventListener(eventName, touchedFn));\n\n\tconst touchedFn = () => {\n\t\tcontrol.setTouched(true);\n\t\tunregister();\n\t}\n\n\teventNames.forEach(eventName => el.addEventListener(eventName, touchedFn));\n\n\treturn {\n\t\tdestroy() {\n\t\t\tunregister();\n\t\t\tstateSub();\n\t\t}\n\t}\n};\n\nexport const controlErrorFactory = ({ onlyTouched = false } = {}) =>\n\t(el: HTMLElement, control: ControlBase) => {\n\t\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\t\tconst stateSub = control.state.subscribe(_state => {\n\t\t\tconst state = (_state as $ControlState);\n\t\t\tconst hasError = !!((!onlyTouched || state.$touched) && state.$error);\n\t\t\tel.hidden = !hasError;\n\t\t\tif (hasError) el.innerHTML = state.$error!;\n\t\t});\n\n\t\treturn { destroy: stateSub };\n\t};\n\n\nexport const controlError = controlErrorFactory();\n","export type ValidatorFn<T = any> = (fieldValue: T) => string | null;\n\ntype ValidatorFactory<T = unknown> = (message: string, config?: T) => ValidatorFn;\n\nconst empty = (value: any) => value == null || `${value}` === '';\n\nexport const required: ValidatorFactory = (message, trim = true) => value => {\n\tlet stringValue = value != null ? `${value}` : '';\n\tif (trim) stringValue = stringValue.trim();\n\treturn stringValue !== '' ? null : message;\n};\n\nconst emailFormat = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\nexport const email: ValidatorFactory = message => email => {\n\tconst valid = empty(email) || emailFormat.test(email);\n\treturn valid ? null : message;\n};\n\nexport const minLength: ValidatorFactory<number> = (message, min) => value => {\n\tconst valid = empty(value) && (min == null || `${value}`.length >= min);\n\treturn valid ? null : message;\n};\n\nexport const maxLength: ValidatorFactory<number> = (message, max) => value => {\n\tconst valid = empty(value) && (max == null || `${value}`.length <= max);\n\treturn valid ? null : message;\n};\n\nexport const number: ValidatorFactory = message => number => {\n\tconst valid = empty(number) || !isNaN(number);\n\treturn valid ? null : message;\n};\n\nconst decimalFormat = /^[\\d.]+$/;\nexport const decimal: ValidatorFactory = message => number => {\n\tconst valid = empty(number) || !isNaN(number) && decimalFormat.test(`${number}`);\n\treturn valid ? null : message;\n};\n\nconst intFormat = /^[\\d]+$/;\nexport const integer: ValidatorFactory = message => number => {\n\tconst valid = empty(number) || !isNaN(number) && intFormat.test(`${number}`);\n\treturn valid ? null : message;\n};\n\n\n\nexport const min: ValidatorFactory<number> = (message, min) => number => {\n\tconst valid = empty(number) || !isNaN(number) && (min == null || number >= min);\n\treturn valid ? null : message;\n};\n\nexport const max: ValidatorFactory<number> = (message, max) => number => {\n\tconst valid = empty(number) || !isNaN(number) && (max == null || number <= max);\n\treturn valid ? null : message;\n};\n\nexport const pattern: ValidatorFactory<RegExp> = (message, re) => text => {\n\tconst valid = empty(text) || (re == null || re.test(text));\n\treturn valid ? null : message;\n};\n\n"],"names":["validateIterated","validators","fieldValue","Array","isArray","validator","result","e","console","error","ControlBase","[object Object]","this","length","Control","initial","super","writable","derived","value","touched","$touched","$error","$valid","$dirty","set","objectPath","ControlGroup","controls","keys","Object","readables","map","key","control","values","reduce","acc","index","controlsValueReadable","state","states","controlsStateReadable","subscribe","valueReadable","setValue","update","updater","get","childStateReadable","childState","children","childrenValid","forEach","setTouched","path","_","name","rest","match","getControl","reset","arrayPath","ControlArray","_controls","controlStore","valueDerived","childStateDerived","i","len","size","stores","push","splice","start","end","slice","controlClasses","el","Error","classList","stateSub","add","remove","eventNames","unregister","eventName","removeEventListener","touchedFn","addEventListener","controlErrorFactory","onlyTouched","destroy","_state","hasError","hidden","innerHTML","controlError","empty","required","message","trim","stringValue","emailFormat","email","test","minLength","min","maxLength","max","number","isNaN","decimalFormat","decimal","intFormat","integer","pattern","re","text"],"mappings":"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"}